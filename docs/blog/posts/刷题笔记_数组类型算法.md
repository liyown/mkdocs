---
title: 数组算法
date: 2024-04-16
authors: [刘耀文]
categories:
  - 刷题笔记
---

# 数组类型算法

## 1、数组理论基础

数组在内存中是以连续空间储存的，所以具有查询快速的优点，但是正式这个特点导致插入元素的时候需要将插入的位置腾空，则需要将插入位置与之后的所有元素进行后移一个位置，导致插入（删除）的操作时间复杂度比较高。
<!-- more -->
**使用场景：**对插入操作比较频繁的场景不适合使用，用于保存数据，例如java中的String类型底层是一个byte数组，HashMap中是一个Int类型数组（严格来说，数组的使用利于HashCode的定位，但是如果冲突严重，会导致查询效率变低（逐渐退化为链表或者红黑树））。

**数组下标的理解：**数组在计算的索引不像自然索引（以1开始），而是以0开始，所以在操作数组边界等需要进一步的理解，对于长度为10的数组，为了遍历可以使用下面两种方式（先不考虑增强for循环）

```java
int[] arrs = new int[]{1,2,3,4,5,6,7,8,9,10};
for(int i=0; i<10; i++) {
    arrs[i]
}

for(int i=1; i<=10; i++) {
    arrs[i-1]
}
```

第一种是对计算机友好，第二种对阅读（for循环的边界条件）友好，例如我需要遍历第2到第5的位置，第一种的做法是

```
for(int i=2-1; i<5; i++) {
    arrs[i]
}
```

是不是觉得for循环中的边界条件很奇怪，不利于理解。如果使用第二种

```
for(int i=2; i<=5; i++) {
    arrs[i-1]
}
```

这个对与for循环的边界就可以很好的理解（习惯了自然索引），但是对于计算机而言，我们需要-1，这是不利于理解的。

使用哪一种呢？我们对比一下

```
n = arrs.length();

for(int i=0; i<n/2; i++) {
    arrs[i]
}

for(int i=n/2; i<n; i++) {
    arrs[i]
}

// 这里n/2的计算结果
// 长度为偶数的时候为后半段元素的第一个 计算机下标
// 长度为奇数的时候为后半段元素的第一个 计算机下标，此时后半段数量多一，这是由于向下取整 3/2=1
// 这个时候，前后半段的分界线交给了 `<` 维护，视觉上看起来 n/2 这个值被两个循环依赖了，但是前后循环应该是独立的。

// 如果使用自然下标遍历则变成
for(int i=1; i<=n/2 -1; i++) {
    arrs[i-1]
}

for(int i=n/2; i<=n; i++) {
    arrs[i-1]
}

//这个时候两个边界 n/2 -1 和 n/2 自然分开，符合我们的常规思维，但是对于数组的读取需要减去1，维护的心智压力增大，所以选择哪个应该看场景，对数组的操作多还是对for循环的逻辑划分多
```

## 2、二分查找

```java
public static int binarySearch(int[] arrs, int target) {
    int pre = -1;
    int tail = arrs.length;
    int mid = 0;

    while(true) {
        mid = (tail + pre) /2;

        if(mid == pre || mid ==tail) return -1;

        if(arrs[mid] == target) return mid;

        if(arrs[mid] < target) {
            pre = mid;
        }
        if(arrs[mid] > target) {
            tail = mid;
        }

    }

}
```